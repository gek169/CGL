Tinyspike is a tile-based dungeon exploration RPG and dungeon crawler with an emphasis on
fast action gameplay.

Combat consists of either attacking enemies with a sword or shooting them with a gun.

The main game can be controlled entirely using ZXC and the arrow keys.
Enter pauses the game.

??Camera rotation?? (ASDF)

Equivalents exist on the controller using the joypad.

Clicking on a location on the screen should also move you there.
Right clicking should shoot/attack in that direction.

Z: Interact or Lock Target (Toggle by default, when you tap z,
you continuously aim at a target until you tap z again or go out of range)
X: Interact or Lock Direction (Toggle by default. When you tap x, 
your direction is locked until you tap again, and your direction becomes unlocked)
C: Fire

The buttons are obviously configurable but this is the target keybinding.

Maps are 2D, transitioned between using doors.

We will not support multi-level levels. Levels are completely flat. This simplifies the creation of geometry.

We might support staircases that go up/down between levels.


STRUCTURES NEEDED
struct Entity{
	physobject physical; //Physical collideable object. Contains rotation too.
	GLuint displaylists[128][256]; //All possible animation frames
	int numanims;
	unsigned int animlengths[128];
	unsigned int currentanim;
	unsigned int animframe;
	unsigned int data[16];
	float frametime; //time between frames of animation
	unsigned char animlooping; //is this animation looping?
	GLuint texture; //Texture of this entity
	unsigned char stippleLevel; //Specifies stippling level. 0 means no stippling, 16 or up means do not render.
	unsigned char isTextured; //bool
	char* fileprototype; //File from which the entity's base data was retrieved. Texture, model list, etcetera.
	unsigned int id; //Custom ID
};
struct Tile{
	physobject physical; //A block of varying height.
	unsigned short type; //0xFF FF
	//type: floor, short wall, medium wall, tall wall, door, doorless, holedeadly, holenice... repeated for all 16 styles (1234567890ABCDEF) (highest byte)
	//direction: UDLR (2nd byte)
	GLuint texture;
	unsigned char stippleLevel; //Specifies stippling level. 0 means no stippling, 16 or up means do not render.
	unsigned char isTextured; //Invoke glBindTexture and glEnable(GL_TEXTURE_2D) ?
};
struct Light{
	vec3 pos;
	vec3 diff;
	vec3 amb;
	vec3 spec;
	unsigned char isEnabled, isFlickering;
	float flickerVariation; //0-1. Determines a range for random numbers, which are then clamped to 0-1
};

Levels are specified like this in a text file. slash slash comments are not part of the file.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
!exclamation mark lines are comments. As soon as an exclamation mark is reached, parsing stops.
!Including comments and newline, a line may never exceed 8,000 characters or the behavior is UNDEFINED
LEVELNAME MyFavoriteLevel
LEVELSTYLESHEET myStyleSheet.txt
!Lines which give filenames do not have the exclamation mark exception.
!Stylesheets contain lists of models to use for floors, walls, etcetera as well as textures.
BEGIN_LEVEL !Note that it's very important that there be absolutely no whitespace or blank lines
###############w#######################################!q is a door at the top. Lowercase means it has a door.
#    #       #   #             #                      #!Doors are numbered from top left, going across and down
#            #   #             #                      #! the top most w is door 0, pointing DOWN (UDLR convention)
######  ###  ## ##             #                      r!1 door
#         #  #                 #############          #
#         #  #      X          #                      r!2 door
########  ##     XXXXX                                #!the X's are a giant hole in the ground. You can fall in if it's capital X
#                XXXXX         #####################  #!There are no stairways, but s is a stair down, S is a stair up. They count as doors.
#     #q##                     ##   #   #   #   #     #!3 for this q
#     e##r                     ##     #   #   #   #   #!4 and 5 for e and r
###############W#######################################!w is a door at the bottom. six. It is just a hole in the wall, capital
END_LEVEL
!NOTES ON LEVEL GEOMETRY SPECIFICATION:
!The length of the first line determines the width of the level. Incomplete lines thereafter generate floor to fill in.
!The first line's width is determined by measuring the number of characters before the newline or an exclamation mark.

BEGIN_STYLE
1111111111111111111111111111111111111111111111111111111!1 is not actually the default style. zero is. This level
1111111111111111111111111111111111111111111111111111111!doesn't use the "base style"
1111111111111111111111111111111111111111111111111111111
1111111111111111111111111111111111111111111111111111111
1111111111111111111111111111111111111111111111111111111
1111111111111111111111111111111111111111111111111111111
1111111111111111111111111111111111111111111111111111111
1111111111111111111111111111111222222222222222222222222!this area is styled 2 it must be special
1111111111111111111111111111111222222222222222222222222!the style area's width is determined
1111111111111111111111111111111222222222222222222222222!by number of valid characters in-a-row in the first line.
1111111111111111111111111111111222222222222222222222222!Areas in the map without a specified style use default 0.
END_STYLE
!the following is the style sheet.
!it specifies where we get the textures for the walls/floors
!
STYLESHEET
0:DebugStyle.jpg
1:myFirstStyle.jpg
2:mySecondStyle.jpg
ENDSTYLESHEET
BEGINLIGHTDATA
LIGHT0 !this line enables LIGHT0 and sets it as the active light to modify.
X 1
Y 1
Z 1
DR 40 !Diffuse Red. Note these numbers are not 0-1 because of how GL 1.1 does lighting!
DG 40 !Diffuse Green
DB 40 !Diffuse Specular
AR 0.2 !Ambient
AG 0.2
AB 0.2
SR 0 !Specular.
SG 0
SB 0
!You could specify LIGHT1 through LIGHT15, as that's what TinyGL supports.
ENDLIGHTDATA

BEGINENTITYDATA
!Entity information when opening the level.
ENTITY myFavoriteEntity
!Lines including strings do not allow exclamation mark comments at the end either.
!Declaring ENTITY <name> is enough to begin
ENTITYDEF myEntityDefinition.txt
!the above line uses that text file to retrieve entity definition information
!This includes a specification of its Mass, animations, AI, etcetera
!Everything needed to describe the "type" of entity.
X 1
Y 4
ROT 90
!What rotation, counterclockwise from 3 o'clock, in degrees, should it be given?
INITANIM 0 0
!What animation frame should it be placed in initially?
ENTITYDATA 0
!Custom entity state data. Up to 16 different values can be stored, as unsigned integers.
ENDENTITYDATA

BEGINDOORDATA
0 NULL 0 0 270
!if NULL is the filename, then the door cannot be entered.
!the other numbers specify x and y position, and rotation for the player after walking through.
!negative rotations are simply subtracted from 360 to get the correct rotation
!Rotations greater than 360 degrees are not allowed.
!Rotations are floating point.
1 myOtherFavoriteLevel.txt 40 10 10
!Note that filenames must not contain spaces.
2 myOtherFavoriteLevel.txt 40 12 -10
3 NULL 0 0 0
4 NULL 0 0 0
5 NULL 0 0 0
ENDDOORDATA

LEVELSCRIPT myLevelScript.lua
!if we do code lua support, we'll implement lua scripting through .lua files

SAVEDATA
!this section only exists in a save file, or a level which resets the player's stats (I.E. first level)
!If an inventory section exists, then the player's inventory is replaced with the inventory
!specified in the section.
PLAYERINVENTORY
Iron_Sword 1 EQ0
!The player has their iron sword equipped in slot zero, the fire button
Health_Potion 14
!They appear to be stocking up on health potions!
!Not equipped.
Magic_Candy 43
!Candy is not very good for you. it is not equipped.
!Items will be named. Names get looked up in a per-game lookup table to get Item IDs and menu icons.
ENDPLAYERINVENTORY
PLAYERHEALTH 10
PLAYERXP 34
ENDSAVEDATA

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

HOW WILL SAVES WORK?
Save the level format as described above. When we attempt to retrieve a level file we check prefpath/save0/ first.
The player is an entity (ID: Zero) and can be saved normally.

PER-ENEMY AI
Either implemented through lua scripts, or selected from a pre-defined series of prototypes.
They'll use the same textures regardless of a level's style.

PLAYER INVENTORY
The player has items stored by ID (names and icons looked up in a table) and in quantities.

Of these items, particular stacks can be "equipped" or not. This determines what the fire button does, how much
damage the player takes, etcetera depending on how the game code handles a particular item.

